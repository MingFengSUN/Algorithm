# 一、算法复杂度分析

## 1、排序算法复杂度

| Algorithm        | Average              | Best       | Worst      | Space   |
| ---------------- | -------------------- | ---------- | ---------- | ------- |
| 快速排序(不稳定) | O(N(LogN))O(N(LogN)) | O(N(LogN)) | O(N^2)     | O(LogN) |
| 归并排序(稳定)   | O(N(LogN))           | O(N(LogN)) | O(N(LogN)) | O(N)    |
| 堆排序(不稳定)   | O(N(LogN))           | O(N(LogN)) | O(N(LogN)) | O(1)    |
| 冒泡排序(稳定)   | O(N^2)               | O(N)       | O(N^2)     | O(1)    |
| 插入排序(稳定)   | O(N^2)               | O(N)       | O(N^2)     | O(1)    |
| 选择排序(不稳定) | O(N^2)               | O(N^2)     | O(N^2)     | O(1)    |

## 2、递归调用的复杂度分析

- 如果递归函数中，只进行一次递归调用，递归深度为 Depth，在每个递归函数中，时间复杂度为 T，则总体的时间复杂度为 O(T*Depth)，如二分查找为 O(LogN)

- 递归中多次进行递归调用，通过**递归树**求解

  ```java
  int f(n) {
      if (n == o)	return 1;
      return f(n - 1) + f(n - 1);
  }
  ```

  对于上面这段代码，递归深度为 N，每一层的需要处理的数据量是 2^N，则通过数学归纳法得出 O(2^(N+1))

  ```java
  //归并排序
  void mergeSort(int arr[], int l, int r) {
      if (l >= r)	return;
      int mid = (l + r)/2;
      mergeSort(arr, l, mid);
      mergeSort(arr, mid + 1, r);
      merge(arr, l, mid, r);
  }
  ```

  对于上面这段代码，递归调用的深度为 LogN，每一层需要处理的数据量是 N，则时间复杂度为 O(NLogN)

## 3、均摊复杂度分析

假设当前数组的容量为 n，那么每添加一个元素需要消耗的时间就是 1，在添加第 n+1 个元素的时候，需要先开辟一个容量为 2n 的数组，然后将前 n 个元素复制到新数组中，同时再将第 n+1 个元素添加进去，综合来看，数组添加 n+1 个元素，需要消耗 n+n 的时间，则平均每次添加操作需要的时间是 2，即 O(1)

# 二、数组中的问题

