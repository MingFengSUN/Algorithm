## 高级排序  
### 归并排序  `O(N*logN)`  
**缺点**：归并排序需要在存储器中有另一个大小等于被排序的数组项数的数组，如果初始数组几乎占满了整个存储器，那么归并排序并不能工作。    
归并算法的中心思想是归并两个有序的数组，可以通过递归和非递归实现。          
**递归**：一个数组分成两半，分别排序每一半，然后用`merge()`方法将数组的两半归并成一个有序数组
1. 初始化一个数组，将左右数组的数进行比较，将较小的数存入中间数组
2. 将左右数组剩下的数存到中间数组
3. 将中间数组复制回原来的数组         
**非递归**：将数组中的相邻元素两两配对，用`merge()`函数将他们排序，构成n/2组长度为2的排序好的子数组段，然后将他们排序成长度为4的子数组段，如此继续，直至整个数组排好序。
1. 从归并段的长度为1开始，一次使归并段的长度变为原来的2倍
2. 在每趟归并的过程中，要注意处理归并段的长度为奇数和 最后一个归并段的长度和前面的不等的情况，需要做一下处理
### 堆排序 `O(N*logN)`
**基本思想**：使用普通的`insert()`在堆中插入全部无序的数据项，然后重复用`remove()`按序移除所有数据项。
```java
for(int j=0;j<size;j++)
    theHeap.insert(array[j]);
for(int i=0;i<size;i++)
    array[i]=theHeap.remove();
```

